/****
 * CSX Project: Program 3: Parser
 * @Authors:  Long Bui and Shane Hall  
 *
 ***/

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

//**************************TERMINALS*************************************
//-----------------------RESERVED WORDS-----------------------------------
terminal CSXToken               rw_IF, rw_BOOL, rw_BREAK, rw_INT,
                                rw_CHAR, rw_READ, rw_CLASS, rw_CONST, 
                                rw_CONTINUE, rw_ELSE, rw_FALSE, rw_FLOAT,
                                rw_RETURN, rw_TRUE, rw_VOID, rw_PRINT, rw_WHILE;

//------------------IDENTIFIERS AND LITERALS------------------------------
terminal CSXIntLitToken         INTLIT; 
terminal CSXFloatLitToken       FLOATLIT; 
terminal CSXStringLitToken      STRLIT;
terminal CSXCharLitToken        CHARLIT;
terminal CSXIdentifierToken     IDENTIFIER;

//-------------------------OPERATORS--------------------------------------
terminal CSXToken               PLUS, NOTEQ, SEMI, SLASH, RPAREN, LPAREN, NOT,
                                LT, COMMA, GEQ, RBRACE, LBRACE, COR, EQ,
                                ASG, TIMES, COLON, LBRACKET, RBRACKET, CAND,
                                LEQ, GT, MINUS;
//terminal CSXToken             INC, DEC;

//----------------------NEW OPERATORS-------------------------------------
terminal CSXToken		ENDIF;


//***************************NON TERMINALS*********************************
non terminal classNode          Program;
non terminal memberDeclsNode    Memberdecls;
non terminal fieldDeclsNode     Fielddecls;
non terminal methodDeclsNode    Methoddecls;
//non terminal stmtNode           OptionalSemi;
non terminal methodDeclNode     Methoddecl;
non terminal argDeclsNode       Argdecls;
non terminal argDeclNode        Argdecl;
non terminal declNode           Fielddecl;
non terminal stmtsNode          Stmts;
non terminal stmtNode           Stmt;
non terminal typeNode           Type;
non terminal argsNode           Args;
non terminal stmtNode           Readlist;
non terminal stmtNode           Printlist;
non terminal exprNode           Expr;
non terminal exprNode           Term;
non terminal exprNode           Factor;
non terminal exprNode           Pri;
non terminal exprNode           Unary;
non terminal exprNode           Unit;
non terminal nameNode           Name;


//----------------------------CSX GRAMMAR---------------------------------
start with Program; 

Program         ::= rw_CLASS:class IDENTIFIER:id LBRACE Memberdecls:member RBRACE
                    {: 
                        RESULT= new classNode(id, members, class.linenum, class.colnum); 
                    :}
                ;
Memberdecls     ::= Fielddecl:f Memberdecls:m
                    {:  
                        RESULT= new memberDeclsNode(
                        new fieldDeclsNode(f,m.fields, f.linenum,f.colnum), 
                        m, f.linenum, f.colnum); 
                    :}

                |   Methoddecls:m
                    {: 
                        RESULT= new memberDeclsNode(fieldDeclsNode.NULL, m, m.linenum, m.colnum); 
                    :}
                ;
Fielddecls      ::= Fielddecl:f1 Fielddecls:f2
                    {: 
                        RESULT= new fieldDeclsNode(f1, f2, f1.linenum, f1.colnum); 
                    :}
                |
                    {: 
                        RESULT= fieldDeclsNode.NULL; 
                    :}
                ;
Methoddecls     ::= Methoddecl:m1 Methoddecls:m2
                    {: 
                        RESULT= new methodDeclsNode(m1, m2, m1.linenum, m1.colnum); 
                    :}
                |
                    {: 
                        RESULT= methodDeclsNode.NULL;
                    :}
                ;
//OptionalSemi  ::= SEMI:s
//                  {: 
//                        RESULT= stmtNode.NULL; 
//                  :}
//              |
//                  {: 
//                        RESULT= stmtNode.NULL; 
//                  :}
//              ;
Methoddecl      ::= rw_VOID:v IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE SEMI 
                    {: 
                        RESULT= new methodDeclNode(id, argDeclsNode.NULL, 
                        new voidTypeNode(v.linenum, v.colnum), f, s, v.linenum, v.colnum); 
                    :}

                |   rw_VOID:v IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE  
                    {: 
                        RESULT= new methodDeclNode(id, argDeclsNode.NULL, 
                        new voidTypeNode(v.linenum, v.colnum), f, s, v.linenum, v.colnum); 
                    :}
                |   rw_VOID:v IDENTIFIER:id LPAREN Argdecls:a RPAREN LBRACE Fielddecls:f Stmts:s RBRACE SEMI 
                    {: 
                        RESULT= new methodDeclNode(id, a, 
                        new voidTypeNode(v.linenum, v.colnum), f, s, v.linenum, v.colnum); 
                    :}
                |   rw_VOID:v IDENTIFIER:id LPAREN Argdecls:a RPAREN LBRACE Fielddecls:f Stmts:s RBRACE  
                    {: 
                        RESULT= new methodDeclNode(id, a, 
                        new voidTypeNode(v.linenum, v.colnum), f, s, v.linenum, v.colnum); 
                    :}
                |   Type:t IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE SEMI 
                    {: 
                        RESULT= new methodDeclNode(id, argDeclsNode.NULL, t, f, s, t.linenum, t.colnum); 
                    :} 
 
                |   Type:t IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE  
                    {: 
                        RESULT= new methodDeclNode(id, argDeclsNode.NULL, t, f, s, t.linenum, t.colnum); 
                    :}

                |   Type:t IDENTIFIER:id LPAREN Argdecls:a RPAREN LBRACE Fielddecls:f Stmts:s RBRACE SEMI 
                    {: 
                        RESULT= new methodDeclNode(id, a, t, f, s, t.linenum, t.colnum); 
                    :}

                |   Type:t IDENTIFIER:id LPAREN Argdecls:a RPAREN LBRACE Fielddecls:f Stmts:s RBRACE  
                    {: 
                        RESULT= new methodDeclNode(id, a, t, f, s, t.linenum, t.colnum); 
                    :}
                ;
Argdecls        ::= Argdecl:a1 COMMA Argdecls:a2
                    {: 
                        RESULT= new argDeclsNode(a1, a2, a1.linenum, a1.colnum); 
                    :}

                |   Argdecl:a
                    {: 
                        RESULT= new argDeclsNode(a, argDeclsNode.NULL, a.linenum, a.colnum); 
                    :}
                ;
Argdecl         ::= Type:t IDENTIFIER:id
                    {: 
                        RESULT= new valArgDeclNode(id, t, t.linenum, t.colnum); 
                    :}

                |   Type:t IDENTIFIER:id LBRACKET RBRACKET
                    {: 
                        RESULT= new arrayArgDeclNode(id, t, t.linenum, t.colnum); 
                    :}   
                ;
Fielddecl       ::= Type:t IDENTIFIER:id SEMI
                    {: 
                        RESULT= new varDeclNode(id, t, exprNode.NULL, t.linenum, t.colnum); 
                    :}

                |   Type:t IDENTIFIER:id ASG Expr:e SEMI
                    {: 
                        RESULT= new varDeclNode(id, t, e, t.linenum, t.colnum); 
                    :}

                |   Type:t IDENTIFIER:id LBRACKET INTLIT:i RBRACKET SEMI
                    {: 
                        RESULT= new arrayDeclNode(id, t, 
                        new intLitNode(i.intValue, t.linenum, t.colnum),
                        t.linenum, t.colnum); 
                    :}

                |   rw_CONST:c IDENTIFIER:id ASG Expr:e SEMI
                    {: 
                        RESULT= new constDeclNode(id, e, c.linenum, c.colnum); 
                    :}
                ;
Stmts           ::= Stmt:s1 Stmts:s2
                    {: 
                        RESULT= new stmtsNode(s1, s2, s1.linenum, s1.colnum); 
                    :}

                |   Stmt:s
                    {: 
                        RESULT= new stmtsNode(s, stmtsNode.NULL, s.linenum, s.colnum); 
                    :}
                ;
Stmt            ::= rw_IF:i LPAREN Expr:e RPAREN Stmt:s ENDIF
                    {: 
                        RESULT= new new ifThenNode(e,
                        new stmtsNode(stmtNode.NULL, s, i.linenum, i.colnum),
                        stmtNode.NULL, i.linenum, i.colnum);
                    :}
                |   rw_IF:i LPAREN Expr:e RPAREN Stmt:s1 rw_ELSE Stmt:s2 ENDIF
                    {: 
                        RESULT= new ifThenNode(e,
                        new stmtsNode(stmtNode.NULL, s1,i.linenum,i.colnum),
                        new stmtsNode(stmtNode.NULL, s2,i.linenum,i.colnum),
                        i.linenum,  i.colnum);
                    :}
                |   rw_WHILE:w LPAREN Expr:e RPAREN Stmt:s
                    {: 
                        RESULT= new whileNode(exprNode.NULL, e, s, w.linenum, w.colnum); 
                    :}
			
                |   IDENTIFIER:id COLON rw_WHILE:w LPAREN Expr:e RPAREN Stmt:s
                    {: 
                        RESULT= new whileNode(id, e, s, w.linenum, w.colnum); 
                    :}

                |   Name:n ASG Expr:e SEMI
                    {: 
                        RESULT= new asgNode(n, e, n.linenum.n.colnum); 
                    :}

                |   rw_READ:r LPAREN Readlist:rl RPAREN SEMI
                    {: 
                        RESULT= new readNode(nameNode.NULL, rl, r.linenum, r.colnum); 
                    :} 
	
                |   rw_PRINT:p LPAREN Printlist:pl RPAREN SEMI
                    {: 
                        RESULT= new printNode(nameNode.NULL, pl, p.linenum, p.colnum); 
                    :} 

                |   IDENTIFIER:id LPAREN RPAREN SEMI
                    {: 
                        RESULT= new callNode(id, argsNode.NULL, id.linenum, id.colnum); 
                    :}
					
                |   IDENTIFIER:id LPAREN Args:a RPAREN SEMI
                    {: 
                        RESULT= new callNode(id, a, id.linenum, id.colnum); 
                    :}

                |   rw_RETURN:r SEMI
                    {: 
                        RESULT= new returnNode(exprNode.NULL, r.linenum, r.colnum); 
                    :}

                |   rw_RETURN:r Expr:e SEMI
                    {: 
                        RESULT= new returnNode(e, r.linenum, r.colnum); 
                    :}

                |   rw_BREAK:b IDENTIFIER:id SEMI
                    {: 
                        RESULT= new breakNode(id, b.linenum, b.colnum); 
                    :}

                |   rw_CONTINUE:c IDENTIFIER:id SEMI
                    {: 
                        RESULT= new continueNode(id, c.linenum, c.colnum); 
                    :}

                |   LBRACE:l Fielddecls:f Stmts:s SEMI
                    {: 
                        RESULT= new blockNode(f, s,lb.linenum, lb.colnum); 
                    :}

                |   LBRACE:l Fielddecls:f Stmts:s 
                    {: 
                        RESULT= new blockNode(f, s,lb.linenum, lb.colnum); 
                    :}
                ;
Type            ::= rw_INT:t
                    {: 
                        RESULT= new intTypeNode(t.linenum, t.colnum); 
                    :}

                |   rw_CHAR:t
                    {: 
                        RESULT= new charTypeNode(t.linenum, t.colnum);
                    :} 

                |   rw_FLOAT:t
                    {:
                        RESULT= new floatTypeNode(t.linenum, t.colnum); 
                    :}

                |   rw_BOOL:t
                    {: 
                        RESULT= new boolTypeNode(t.linenum, t.colnum); 
                    :} 
                ;
Args            ::= Expr:e COMMA Args:a
                    {: 
                        RESULT= new argsNode(e, a, e.linenum, e.colnum); 
                    :}

                |   Expr:e
                    {: 
                        RESULT= new argsNode(e, argsNode.NULL, e.linenum, e.colnum): 
                    :}
                ;
Readlist        ::= Name:n COMMA Readlist:r
                    {: 
                        RESULT= new readNode(n, r, n.linenum, n.colnum); 
                    :}
	
                |   Name:n    
                    {: 
                        RESULT= new readNode(n, readNode.NULL, n.linenum, n.colnum); 
                    :}
                ;
Printlist       ::= Expr:e COMMA Printlist:pl
                    {: 
                        RESULT = new printNode(e, pl,  e.linenum, e.colnum); 
                    :}

                |   Expr:e
                    {: 
                        RESULT = new printNode(e, printNode.NULL, e.linenum, e.colnum); 
                    :}
                ;
Expr            ::= Expr:e COR Term:t
                    {: 
                        RESULT = new binaryOpNode(e, sym.COR, t, e.linenum, e.colnum); 
                    :}

                |   Expr:e CAND Term:t
                    {: 
                        RESULT = new binaryOpNode(e, sym.CAND, t, e.linenum, e.colnum); 
                    :}

                |   Term:t
                    {: 
                        RESULT = new unaryOpNode(-1, t, t.linenum, t.colnum); 
                    :} 
                ;
Term            ::= Factor:f1 LT Factor:f2
                    {: 
                        RESULT = new binaryOpNode(f1, sym.LT, f2, f1.linenum, f1.colnum); 
                    :}

                |   Factor:f1 GT Factor:f2
                    {: 
                        RESULT = new binaryOpNode(f1, sym.GT, f2, f1.linenum, f1.colnum); 
                    :}

                |   Factor:f1 LEQ Factor:f2
                    {: 
                        RESULT = new binaryOpNode(f1, sym.LEQ, f2, f1.linenum, f1.colnum); 
                    :}

                |   Factor:f1 GEQ Factor:f2
                    {: 
                        RESULT = new binaryOpNode(f1, sym.GEQ, f2, f1.linenum, f1.colnum); 
                    :}

                |   Factor:f1 EQ Factor:f2
                    {: 
                        RESULT = new binaryOpNode(f1, sym.EQ, f2, f1.linenum, f1.colnum);
                    :}

                |   Factor:f1 NOTEQ Factor:f2
                    {: 
                        RESULT = new binaryOpNode(f1, sym.NOTEQ, f2, f1.linenum, f1.colnum); 
                    :}

                |   Factor:f1
                    {: 
                        RESULT = new unaryOpNode(-1, f1, f1.linenum, f1.colnum); 
                    :} 
                ;
Factor          ::= Factor:f PLUS Pri:p
                    {: 
                        RESULT = new binaryOpNode(f, sym.PLUS, p, f.linenum, f.colnum);
                    :}

                |   Factor:f MINUS Pri:p
                    {: 
                        RESULT = new binaryOpNode(f, sym.MINUS, p, f.linenum, f.colnum); 
                    :}

                |   Pri:p
                    {: 
                        RESULT = new unaryOpNode(-1, p, p.linenum, p.colnum); 
                    :}
                ;
Pri             ::= Pri:p TIMES Unary:u
                    {: 
                        RESULT = new binaryOpNode(p, sym.TIMES, u, p.linenum, p.colnum); 
                    :}

                |   Pri:p SLASH Unary:u
                    {: 
                        RESULT = new binaryOpNode(p, sym.SLASH, u, p.linenum, p.colnum); 
                    :}

                |   Unary:u 
                    {: 
                        RESULT = new unaryOpNode(-1, u, u.linenum, u.colnum); 
                    :} 
                ;
Unary           ::= NOT:n Unary:u
                    {: 
                        RESULT = new unaryOpNode(sym.NOT, u, n.linenum, n.colnum); 
                    :}

                |   LPAREN:l Type:t RPAREN Unary:u
                    {: 
                        RESULT = new castNode(t, u, l.linenum, l.colnum); 
                    :}

                |   Unit:u
                    {: 
                        RESULT = new unaryOpNode(-1, u, u.linenum, u.colnum); 
                    :}
                ;
Unit            ::= Name:n
                    {: 
                        RESULT= new nameNode(identNode.NULL, n, n.linenum, n.colnum); 
                    :}

                |   IDENTIFIER:id LPAREN RPAREN
                    {: 
                        RESULT= new fctCallNode(id, argsNode.NULL, id.linenum, id.colnum); 
                    :}
	
                |   IDENTIFIER:id LPAREN Args:a RPAREN
                    {: 
                        RESULT= new fctCallNode(id, a, id.linenum, id.colnum); 
                    :}

                |   INTLIT:l
                    {: 
                        RESULT= new intLitNode(l, l.linenum, l.colnum); 
                    :}

                |   CHARLIT:l
                    {: 
                        RESULT= new charLitNode(l, l.linenum, l.colnum); 
                    :}

                |   FLOATLIT:l
                    {: 
                        RESULT= new floatLitNode(l, l.linenum, l.colnum); 
                    :}

                |   STRLIT:l
                    {: 
                        RESULT= new strLitNode(l, l.linenum, l.colnum); 
                    :}

                |   rw_TRUE:l
                    {: 
                        RESULT= new trueNode(l, l.linenum, l.colnum); 
                    :}

                |   rw_FALSE:l
                    {: 
                        RESULT= new falseNode(l, l.linenum, l.colnum); 
                    :}

                |   LPAREN:l Expr:e RPAREN
                    {: 
                        RESULT= new argsNode(e, argsNode.NULL, 1.linenum, 1.colnum); 
                    :}
                ;
Name            ::= IDENTIFIER:id
                    {: 
                        RESULT= new nameNode(id, exprNode.NULL, id.linenum, id.colnum); 
                    :}

                |   IDENTIFIER:id LBRACKET Expr:e RBRACKET
                    {: 
                        RESULT= new nameNode(id, e, id.linenum, id.colnum); 
                    :}
                ;

