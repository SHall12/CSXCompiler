/****
 * CSX Project: Program 3: Parser
 * @Authors:  Long Bui and Shane Hall  
 *
 ***/

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

//**************************TERMINALS*************************************
//-----------------------RESERVED WORDS-----------------------------------
terminal CSXToken               rw_IF, rw_BOOL, rw_BREAK, rw_INT,
                                rw_CHAR, rw_READ, rw_CLASS, rw_CONST, 
                                rw_CONTINUE, rw_ELSE, rw_FALSE, rw_FLOAT,
                                rw_RETURN, rw_TRUE, rw_VOID, rw_PRINT, rw_WHILE;

//------------------IDENTIFIERS AND LITERALS------------------------------
terminal CSXIntLitToken         INTLIT; 
terminal CSXFloatLitToken       FLOATLIT; 
terminal CSXStringLitToken      STRLIT;
terminal CSXCharLitToken        CHARLIT;
terminal CSXIdentifierToken     IDENTIFIER;

//-------------------------OPERATORS--------------------------------------
terminal CSXToken               PLUS, NOTEQ, SEMI, SLASH, RPAREN, LPAREN, NOT,
                                LT, COMMA, INC, GEQ, RBRACE, LBRACE, COR, EQ,
                                ASG, TIMES, COLON, LBRACKET, RBRACKET, CAND,
                                LEQ, DEC, GT, MINUS;

//-----------------------ERROR TOKENS-------------------------------------
terminal CSXErrorToken          error;

/***************************NON TERMINALS*********************************
non terminal classNode          Program;
non terminal memberDeclsNode    Memberdecls;
non terminal fieldDeclsNode     Fielddecls;
non terminal methodDeclsNode    Methoddecls;
non terminal stmtNode           OptionalSemi;
non terminal methodDeclNode     Methoddecl;
non terminal argDeclsNode       Argdecls;
non terminal argDeclNode        Argdecl;
non terminal declNode           Fielddecl;
non terminal stmtsNode          Stmts;
non terminal stmtNode           Stmt;
non terminal typeNode           Type;
non terminal argsNode           Args;
non terminal stmtNode           Readlist;
non terminal stmtNode           Printlist;
non terminal exprNode           Expr;
non terminal exprNode           Term;
non terminal exprNode           Factor;
non terminal exprNode           Pri;
non terminal exprNode           Unary;
non terminal exprNode           Unit;
non terminal nameNode           Name;


//----------------------------CSX GRAMMAR---------------------------------
start with Program; 

Program         ::= rw_CLASS:class IDENTIFIER:id LBRACE Memberdecls:member RBRACE
                    {: RESULT= new classNode(id, members, class.linenum, class.colnum); :}
                ;
Memberdecls     ::= Fielddecl:f Memberdecls:member
                    {: RESULT= new memberDeclsNode(field, member, f.linenum, f.colnum); :}

                |   Methoddecls:m
                    {: RESULT= new memberDeclsNode(fieldDeclsNode.NULL, m, m.linenum, m.colnum); :}
                ;
Fielddecls      ::= Fielddecl:f1 Fielddecls:f2
                    {: RESULT= new fieldDeclsNode(f1, f2, f1.linenum, f1.colnum); :}
                |
                    {: RESULT= fieldDeclsNode.NULL; :}
                ;
Methoddecls     ::= Methoddecl:m1 Methoddecls:m2
                    {: RESULT= new methodDeclsNode(m1, m2, m1.linenum, f1.colnum); :}
                |
                    {: RESULT= new methodDeclsNode.NULL) :}
                ;
OptionalSemi    ::= SEMI:s
                    {: RESULT= stmtNode.NULL; :}
                |
                    {: RESULT= stmtNode.NULL; :}
                ;
Methoddecl      ::= rw_VOID:v IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE OptionalSemi 
                    {: RESULT= new methodDeclNode(id, argDeclsNode.NULL, 
                        new voidTypeNode(v.linenum, v.colnum), f, s, v.linenum, v.colnum); 
                    :}
                |   rw_VOID:v IDENTIFIER:id LPAREN Argdecls:a RPAREN LBRACE Fielddecls:f Stmts:s RBRACE OptionalSemi 
                    {: RESULT= new methodDeclNode(id, a, 
                        new voidTypeNode(v.linenum, v.colnum), f, s, v.linenum, v.colnum); 
                    :}
                |   Type:t IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE OptionalSemi 
                    {: RESULT= new methodDeclNode(id, argDeclsNode.NULL, t, f, s, t.linenum, t.colnum); :}
                
                |   Type:t IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:f Stmts:s RBRACE OptionalSemi 
                    {: RESULT= new methodDeclNode(id, a, t, f, s, t.linenum, t.colnum); :}
                ;
Argdecls        ::= Argdecl:a1 Argdecls:a2
                    {: RESULT= new argDeclsNode(a1, a2, a1.linenum, a1.colnum); :}

                |   Argdecl:a
                    {: RESULT= new argDeclsNode(a, argDeclsNode.NULL, a.linenum, a.colnum); :}
                ;
Argdecl         ::= Type:t IDENTIFIER:id
                    {: RESULT= new valArgDeclNode(id, t, t.linenum, t.colnum); :}

                |   Type:t IDENTIFIER:id LBRACKET RBRACKET
                    {: RESULT= new valArgDeclNode(id, t, t.linenum, t.colnum); :}   
                ;
Fielddecl       ::= Type:t IDENTIFIER:id SEMI
                    {: RESULT= new varDeclNode(id, t, exprNode.NULL, t.linenum, t.colnum; :}

                |   Type:t IDENTIFIER:id ASG Expr:e SEMI
                    {: RESULT= new varDeclNode(id, t, e, t.linenum, t.colnum; :}

                |   Type:t IDENTIFIER:id LBRACKET INTLIT RBRACKET SEMI
                    {: RESULT= new varDeclNode(id, t, exprNode.NULL, t.linenum, t.colnum; :}

                |   rw_CONST:c IDENTIFIER:id Expr:e SEMI
                    {: RESULT= new constDeclNode(id, e, c.linenum, c.colnum; :}
                ;
Stmts           ::= Stmt:s1 Stmts:s2
                    {: RESULT= new stmtsNode(s1, s2, s1.linenum, s1.colnum; :}

                |   Stmt:s
                    {: RESULT= new stmtsNode(s, stmtsNode.NULL, s.linenum, s.colnum; :}
                ;
Stmt            ::= 


                |   


                |   


                |   


                |  


                |   


                |   


                |   


                |   


                |   


                |   


                |   


                |   


                |   


                ;
Type            ::= 


                |   


                |   


                |   


                ;

Args            ::= 


                |   


                ;
Readlist        ::= 


                |   


                ;
Printlist       ::= 


                |   


                ;
Expr            ::= 


                |   


                |   

                ;
Term            ::= 


                |   


                |   


                |   


                |   


                |   


                |   


                ;
Factor          ::= 


                |   


                |   

                ;
Pri             ::= 


                |   


                |   
                

                ;
Unary           ::= 


                |   


                |   


                ;

Unit            ::= 


                |   


                |   


                |   


                |   


                |   


                |   


                |   


                |   


                |   


                ;

Name            ::= 


                |   


                ;
